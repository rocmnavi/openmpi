.\" Man page generated from reStructuredText.
.
.TH "SHMEM_PTR" "3" "Apr 08, 2024" "" "Open MPI"
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.sp
\fI\%shmem_ptr\fP(3) \- Returns a pointer to a data object on a specified
processing element (PE).
.SH SYNOPSIS
.sp
C or C++:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mpp/shmem.h>

void *shmem_ptr(const void *target, int pe)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Fortran:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
INCLUDE "mpp/shmem.fh"

POINTER (PTR, POINTEE)
INTEGER pe

PTR = SHMEM_PTR(target, pe)
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DESCRIPTION
.sp
The \fI\%shmem_ptr\fP routine returns an address that can be used to directly
reference \fBtarget\fP on the remote PE \fBpe\fP\&. With this address we can
perform ordinary loads and stores to the remote address.
.sp
When a sequence of loads (gets) and stores (puts) to a data object on a
remote PE does not match the access pattern provided in a SHMEM data
transfer routine like \fI\%shmem_put32\fP(3) or shmem_real_iget(3), the
\fI\%shmem_ptr\fP function can provide an efficient means to accomplish the
communication.
.sp
The arguments are as follows:
.INDENT 0.0
.TP
.B target
The symmetric data object to be referenced.
.TP
.B pe
An integer that indicates the PE number on which target is to be
accessed. If you are using Fortran, it must be a default integer
value.
.UNINDENT
.SH EXAMPLES
.sp
This Fortran program calls \fI\%shmem_ptr\fP and then PE 0 writes to the BIGD
array on PE 1:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PROGRAM REMOTEWRITE
  INCLUDE \(aqmpp/shmem.fh\(aq

  INTEGER BIGD(100)
  SAVE BIGD
  INTEGER POINTEE(*)

  POINTER (PTR,POINTEE)
  CALL START_PES(0)
  IF (MY_PE() .EQ. 0) THEN
                             ! initialize PE 1\(aqs BIGD array
    PTR = SHMEM_PTR(BIGD, 1) ! get address of PE 1\(aqs BIGD
                             ! array
    DO I=1,100
      POINTEE(I) = I
    ENDDO
  ENDIF
  CALL SHMEM_BARRIER_ALL
  IF (MY_PE() .EQ. 1) THEN
    PRINT *, \(aqBIGD on PE 1 is: \(aq
    PRINT *, BIGD
  ENDIF
END
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
This is the equivalent program written in C:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mpp/shmem.h>

main()
{
  static int bigd[100];
  int *ptr;
  int i;

  shmem_init();
  if (shmem_my_pe() == 0) {
  /* initialize PE 1\(aqs bigd array */
    ptr = shmem_ptr(bigd, 1);
    for (i=0; i<100; i++)
      *ptr++ = i+1;
  }
  shmem_barrier_all();
  if (shmem_my_pe() == 1) {
    printf("bigd on PE 1 is:\en");
    for (i=0; i<100; i++)
      printf(" %d\en",bigd[i]);
    printf("\en");
  }
}
.ft P
.fi
.UNINDENT
.UNINDENT
.SH NOTES
.sp
The \fI\%shmem_ptr\fP function is available only on systems where ordinary
memory loads and stores are used to implement SHMEM put and get
operations.
.SH RETURN VALUES
.sp
\fI\%shmem_ptr\fP returns a pointer to the data object on the specified remote
PE. If target is not remotely accessible, a NULL pointer is returned.
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
\fIintro_shmem\fP(3) \fIshmem_put\fP(3) \fIshmem_get\fP(3)
.UNINDENT
.UNINDENT
.SH COPYRIGHT
2003-2024, The Open MPI Community
.\" Generated by docutils manpage writer.
.
