.\" Man page generated from reStructuredText.
.
.TH "SHMEM_GET64_NBI" "3" "Apr 08, 2024" "" "Open MPI"
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.INDENT 0.0
.INDENT 3.5
.UNINDENT
.UNINDENT
.sp
\fI\%shmem_getmem_nbi\fP(3), \fI\%shmem_char_get_nbi\fP(3),
\fI\%shmem_short_get_nbi\fP(3), \fI\%shmem_int_get_nbi\fP(3),
\fI\%shmem_long_get_nbi\fP(3), \fI\%shmem_longlong_get_nbi\fP(3),
\fI\%shmem_float_get_nbi\fP(3), \fI\%shmem_double_get_nbi\fP(3),
\fI\%shmem_longdouble_get_nbi\fP(3), \fI\%shmem_get8_nbi\fP(3),
\fI\%shmem_get16_nbi\fP(3), \fI\%shmem_get32_nbi\fP(3), \fI\%shmem_get64_nbi\fP(3),
\fI\%shmem_get128_nbi\fP(3), \- The nonblocking get routines provide a method
for copying data from a contiguous remote data object on the specified
PE to the local data object.
.SH SYNOPSIS
.sp
C or C++:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
#include <mpp/shmem.h>

void shmem_getmem_nbi(void *dest, const void *source,
  size_t nelems, int pe)

void shmem_char_get(char *dest, const char *source,
  size_t nelems, int pe)

void shmem_short_get(short *dest, const short *source,
  size_t nelems, int pe)

void shmem_int_get(int *dest, const int *source,
  size_t nelems, int pe)

void shmem_long_get(long *dest, const long *source,
  size_t nelems, int pe)

void shmem_longlong_get(long long *dest, const long long *source,
  size_t nelems, int pe)

void shmem_float_get(float *dest, const float *source,
  size_t nelems, int pe)

void shmem_double_get(double *dest, const double *source,
  size_t nelems, int pe)

void shmem_longdouble_get(long double *dest, const long double *source,
  size_t nelems, int pe)

void shmem_get8(void *dest, const void *source,
  size_t nelems, int pe)

void shmem_get16(void *dest, const void *source,
  size_t nelems, int pe)

void shmem_get32(void *dest, const void *source,
  size_t nelems, int pe)

void shmem_get64(void *dest, const void *source,
  size_t nelems, int pe)

void shmem_get128(void *dest, const void *source,
  size_t nelems, int pe)
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
Fortran:
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
INCLUDE "mpp/shmem.fh"

INTEGER nelems, pe

CALL SHMEM_GETMEM_NBI(dest, source, nelems, pe)

CALL SHMEM_CHARACTER_GET_NBI(dest, source, nelems, pe)

CALL SHMEM_COMPLEX_GET_NBI(dest, source, nelems, pe)

CALL SHMEM_DOUBLE_GET_NBI(dest, source, nelems, pe)

CALL SHMEM_INTEGER_GET_NBI(dest, source, nelems, pe)

CALL SHMEM_LOGICAL_GET_NBI(dest, source, nelems, pe)

CALL SHMEM_REAL_GET_NBI(dest, source, nelems, pe)

CALL SHMEM_GET4_NBI(dest, source, nelems, pe)

CALL SHMEM_GET8_NBI(dest, source, nelems, pe)

CALL SHMEM_GET32_NBI(dest, source, nelems, pe)

CALL SHMEM_GET64_NBI(dest, source, nelems, pe)

CALL SHMEM_GET128_NBI(dest, source, nelems, pe)
.ft P
.fi
.UNINDENT
.UNINDENT
.SH DESCRIPTION
.sp
The get routines provide a method for copying a contiguous symmetric
data object from a different PE to a contiguous data object on the local
PE. The routines return after posting the operation. The operation is
considered complete after a subsequent call to \fI\%shmem_quiet\fP\&. At the
completion of \fI\%shmem_quiet\fP, the data has been delivered to the dest array
on the local PE.
.sp
The arguments are as follows:
.INDENT 0.0
.TP
.B dest
Local data object to be updated.
.TP
.B source
Data object on the PE identified by pe that contains the data to be
copied. This data object must be remotely accessible.
.TP
.B nelems
Number of elements in the target and source arrays. len must be of
type integer. If you are using Fortran, it must be a constant,
variable, or array element of default integer type.
.TP
.B pe
PE number of the remote PE. pe must be of type integer. If you are
using Fortran, it must be a constant, variable, or array element of
default integer type.
.UNINDENT
.sp
If you are using Fortran, data types must be of default size. For
example, a real variable must be declared as REAL, REAL*4, or
REAL(KIND=4).
.SH NOTES
.sp
See \fIintro_shmem\fP(3) for a definition of the term remotely accessible.
.SH EXAMPLES
.sp
Consider this simple example for Fortran.
.INDENT 0.0
.INDENT 3.5
.sp
.nf
.ft C
PROGRAM REDUCTION
  REAL VALUES, SUM
  COMMON /C/ VALUES
  REAL WORK

  CALL START_PES(0) ! ALLOW ANY NUMBER OF PES
  VALUES = MY_PE() ! INITIALIZE IT TO SOMETHING
  CALL SHMEM_BARRIER_ALL
  SUM = 0.0
  DO I = 0,NUM_PES()\-1
    CALL SHMEM_REAL_GET_NBI(WORK, VALUES, 1, I)
    CALL SHMEM_QUIET                ! wait for delivery
    SUM = SUM + WORK
  ENDDO
  PRINT *, \(aqPE \(aq, MY_PE(), \(aq COMPUTED SUM=\(aq, SUM
  CALL SHMEM_BARRIER_ALL
END
.ft P
.fi
.UNINDENT
.UNINDENT
.sp
\fBSEE ALSO:\fP
.INDENT 0.0
.INDENT 3.5
\fIintro_shmem\fP(3) \fIshmem_quiet\fP(3)
.UNINDENT
.UNINDENT
.SH COPYRIGHT
2003-2024, The Open MPI Community
.\" Generated by docutils manpage writer.
.
